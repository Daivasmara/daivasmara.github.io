<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Automatic NVM Use</title>
      <link href="/2020/07/07/automatic-nvm-use/"/>
      <url>/2020/07/07/automatic-nvm-use/</url>
      
        <content type="html"><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>As a Javascript Engineer I do alot of works with various node versions throughout the week, one day I could be using the old version like <code>v9.7.1</code>, and another day I could be debugging some problems on newer applications that uses node <code>v14.4.0</code> or something. You get the idea.</p><p>Therefore using a version manager tools such as <a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">NVM</a> is just a natural thing to do and I’ve been using it AFAIK for more than a year. Throughout that time I keep tweaking the whole experience because I find some pretty ineffective things that could be improved. Like for example the way it’s loaded is blocking which means it slows my new instance of terminal even when it’s not node related. And some other minor teeny tiny tweaks.</p><p>One of the tweak is to automatically run <code>nvm use</code> whenever there’s a <code>.nvmrc</code> file in the directory, and that’s what this article is gonna be about because from all the tweaks that I did on my local NVM, this is the most helpful one, at least in my opinion.</p><h1 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h1><h2 id="zshrc"><a href="#zshrc" class="headerlink" title=".zshrc"></a>.zshrc</h2><pre><code class="sh">autoload -U add-zsh-hookload-nvmrc() {  local node_version=&quot;$(nvm version)&quot;  local nvmrc_path=&quot;$(nvm_find_nvmrc)&quot;  if [ -n &quot;$nvmrc_path&quot; ]; then    local nvmrc_node_version=$(nvm version &quot;$(cat &quot;${nvmrc_path}&quot;)&quot;)    if [ &quot;$nvmrc_node_version&quot; = &quot;N/A&quot; ]; then      nvm install    elif [ &quot;$nvmrc_node_version&quot; != &quot;$node_version&quot; ]; then      nvm use    fi  elif [ &quot;$node_version&quot; != &quot;$(nvm version default)&quot; ]; then    echo &quot;Reverting to nvm default version&quot;    nvm use default  fi}add-zsh-hook chpwd load-nvmrcload-nvmrc</code></pre><h2 id="bashrc"><a href="#bashrc" class="headerlink" title=".bashrc"></a>.bashrc</h2><pre><code class="sh">find-up () {    path=$(pwd)    while [[ &quot;$path&quot; != &quot;&quot; &amp;&amp; ! -e &quot;$path/$1&quot; ]]; do        path=${path%/*}    done    echo &quot;$path&quot;}cdnvm(){    cd &quot;$@&quot;;    nvm_path=$(find-up .nvmrc | tr -d &#39;\n&#39;)    if [[ ! $nvm_path = *[^[:space:]]* ]]; then        declare default_version;        default_version=$(nvm version default);        if [[ $default_version == &quot;N/A&quot; ]]; then            nvm alias default node;            default_version=$(nvm version default);        fi        if [[ $(nvm current) != &quot;$default_version&quot; ]]; then            nvm use default;        fi        elif [[ -s $nvm_path/.nvmrc &amp;&amp; -r $nvm_path/.nvmrc ]]; then        declare nvm_version        nvm_version=$(&lt;&quot;$nvm_path&quot;/.nvmrc)        declare locally_resolved_nvm_version        locally_resolved_nvm_version=$(nvm ls --no-colors &quot;$nvm_version&quot; | tail -1 | tr -d &#39;\-&gt;*&#39; | tr -d &#39;[:space:]&#39;)        if [[ &quot;$locally_resolved_nvm_version&quot; == &quot;N/A&quot; ]]; then            nvm install &quot;$nvm_version&quot;;        elif [[ $(nvm current) != &quot;$locally_resolved_nvm_version&quot; ]]; then            nvm use &quot;$nvm_version&quot;;        fi    fi}alias cd=&#39;cdnvm&#39;</code></pre><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>You can just simply copy the code above and put it on your respective <code>.zshrc</code> or <code>.bashrc</code> file (depends on what you’re using) after the NVM initialization . The code above will automatically detect whether a <code>.nvmrc</code> file is exist in your current directory and if it is it’ll run <code>nvm use</code>, and if you navigate to other directory where it has no <code>.nvmrc</code> it’ll revert the node version to your default.</p><h1 id="Closing"><a href="#Closing" class="headerlink" title="Closing"></a>Closing</h1><p>I find this extremely helpful because I tend to forgot what my current node version is and it might messed up the current project by introducing incompatible syntax and packages. The code above is not written by me, I find it <a href="https://github.com/nvm-sh/nvm#deeper-shell-integration" target="_blank" rel="noopener">here</a>. So thanks to its awesome documentation. Cheers!</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NVM </tag>
            
            <tag> Node </tag>
            
            <tag> Terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My .vimrc</title>
      <link href="/2020/04/19/my-vimrc/"/>
      <url>/2020/04/19/my-vimrc/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/jQtmpW5.png" alt="My Vim"></p><p>Okay so first of all, a friendly disclaimer: <ins><strong>I’m not a vim expert by any means.</strong></ins> This is just a fun, opiniated/subjective article on what plugins and settings I’m using on my vim and why. Another disclaimer is that this <strong>.vimrc</strong> is far from done and will keep updated every time I feel like it or in some cases <strong>needed</strong> to.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In order to for you to get a better context, this vim setup is used daily by me a <strong>full time javascript engineer</strong> who’s currently doing some <strong>python</strong> and <strong>rust</strong> on the side.</p><h2 id="vimrc"><a href="#vimrc" class="headerlink" title=".vimrc"></a>.vimrc</h2><pre><code class="vim">call plug#begin(&#39;~/.vim/plugged&#39;)Plug &#39;challenger-deep-theme/vim&#39;, { &#39;as&#39;: &#39;challenger-deep&#39; }Plug &#39;junegunn/fzf&#39;, { &#39;dir&#39;: &#39;~/.fzf&#39;, &#39;do&#39;: &#39;./install --all&#39; }Plug &#39;junegunn/fzf.vim&#39;Plug &#39;neoclide/coc.nvim&#39;, {&#39;branch&#39;: &#39;release&#39;}Plug &#39;davidhalter/jedi-vim&#39;Plug &#39;vim-airline/vim-airline&#39;Plug &#39;vim-airline/vim-airline-themes&#39;Plug &#39;junegunn/goyo.vim&#39;Plug &#39;vimwiki/vimwiki&#39;Plug &#39;voldikss/vim-floaterm&#39;Plug &#39;preservim/nerdtree&#39;Plug &#39;preservim/nerdcommenter&#39;Plug &#39;ryanoasis/vim-devicons&#39;Plug &#39;iamcco/markdown-preview.nvim&#39;, { &#39;do&#39;: &#39;cd app &amp; yarn install&#39;  }Plug &#39;airblade/vim-gitgutter&#39;Plug &#39;dense-analysis/ale&#39;Plug &#39;tpope/vim-fugitive&#39;Plug &#39;alvan/vim-closetag&#39;Plug &#39;tpope/vim-surround&#39;Plug &#39;jiangmiao/auto-pairs&#39;Plug &#39;ap/vim-css-color&#39;Plug &#39;ekalinin/Dockerfile.vim&#39;Plug &#39;rust-lang/rust.vim&#39;Plug &#39;plasticboy/vim-markdown&#39;Plug &#39;stephpy/vim-yaml&#39;Plug &#39;mxw/vim-jsx&#39;Plug &#39;pangloss/vim-javascript&#39;Plug &#39;neoclide/jsonc.vim&#39;Plug &#39;leafgarland/typescript-vim&#39;Plug &#39;numirias/semshi&#39;, {&#39;do&#39;: &#39;:UpdateRemotePlugins&#39;}call plug#end()let mapleader = &quot;,&quot;syntax onset encoding=UTF-8set tabstop=8 softtabstop=0 expandtab shiftwidth=2 smarttabset number relativenumberset laststatus=2set noshowmodeset updatetime=250set nocompatiblefiletype plugin onnoremap &lt;Leader&gt;Y &quot;+ynoremap &lt;Leader&gt;P &quot;+pnnoremap gb &lt;C-O&gt;&lt;C-S&gt;nnoremap &lt;C-J&gt; &lt;C-W&gt;&lt;C-J&gt;nnoremap &lt;C-K&gt; &lt;C-W&gt;&lt;C-K&gt;nnoremap &lt;C-L&gt; &lt;C-W&gt;&lt;C-L&gt;nnoremap &lt;C-H&gt; &lt;C-W&gt;&lt;C-H&gt;nnoremap &lt;C-E&gt; &lt;C-W&gt;&lt;C-V&gt;nnoremap &lt;C-O&gt; &lt;C-W&gt;&lt;C-S&gt;autocmd FileType json syntax match Comment +\/\/.\+$+autocmd BufRead,BufNewFile tsconfig.json set filetype=jsonclet g:python3_host_prog = &#39;/usr/bin/python3.8&#39;let g:python_host_prog = &#39;/usr/bin/python2.7&#39;let g:loaded_ruby_provider = 0let g:floaterm_keymap_toggle = &#39;&lt;Leader&gt;`&#39;let g:closetag_filenames = &#39;*.html,*.xhtml,*.phtml,*js,*jsx&#39;let g:ale_linters_explicit = 1let g:gitgutter_realtime = 1let g:rustfmt_autosave = 1let g:vim_markdown_folding_disabled = 1let g:typescript_indent_disable = 1let g:typescript_compiler_binary = &#39;npx tsc&#39;&quot;FZF RGnnoremap &lt;silent&gt; &lt;C-p&gt; :FZF&lt;CR&gt;function! RipgrepFzf(query, fullscreen)  let command_fmt = &#39;rg --column --line-number --no-heading --color=always --smart-case %s || true&#39;  let initial_command = printf(command_fmt, shellescape(a:query))  let reload_command = printf(command_fmt, &#39;{q}&#39;)  let spec = {&#39;options&#39;: [&#39;--phony&#39;, &#39;--query&#39;, a:query, &#39;--bind&#39;, &#39;change:reload:&#39;.reload_command]}  call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)endfunctioncommand! -nargs=* -bang Rg call RipgrepFzf(&lt;q-args&gt;, &lt;bang&gt;0)&quot;Challenger Deeplet g:challenger_deep_termcolors = 16if has(&#39;nvim&#39;) || has(&#39;termguicolors&#39;)  set termguicolorsendifcolorscheme challenger_deep&quot;Vim-Airlinelet g:airline_theme=&#39;deus&#39;let g:airline_powerline_fonts = 1let g:airline#extensions#hunks#enabled = 0&quot;CoCset hiddenset nobackupset nowritebackupset cmdheight=2set shortmess+=cset signcolumn=yesset statusline^=%{coc#status()}%{get(b:,&#39;coc_current_function&#39;,&#39;&#39;)}let g:coc_user_config = 1let g:coc_global_extensions = 1nmap &lt;silent&gt; [g &lt;Plug&gt;(coc-diagnostic-prev)nmap &lt;silent&gt; ]g &lt;Plug&gt;(coc-diagnostic-next)nmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)nmap &lt;silent&gt; gy &lt;Plug&gt;(coc-type-definition)nmap &lt;silent&gt; gi &lt;Plug&gt;(coc-implementation)nmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)nmap &lt;leader&gt;rn &lt;Plug&gt;(coc-rename)nnoremap &lt;silent&gt; &lt;space&gt;a  :&lt;C-u&gt;CocList diagnostics&lt;cr&gt;nnoremap &lt;silent&gt; &lt;space&gt;e  :&lt;C-u&gt;CocList extensions&lt;cr&gt;nnoremap &lt;silent&gt; &lt;space&gt;c  :&lt;C-u&gt;CocList commands&lt;cr&gt;nnoremap &lt;silent&gt; &lt;space&gt;o  :&lt;C-u&gt;CocList outline&lt;cr&gt;nnoremap &lt;silent&gt; &lt;space&gt;s  :&lt;C-u&gt;CocList -I symbols&lt;cr&gt;nnoremap &lt;silent&gt; &lt;space&gt;j  :&lt;C-u&gt;CocNext&lt;CR&gt;nnoremap &lt;silent&gt; &lt;space&gt;k  :&lt;C-u&gt;CocPrev&lt;CR&gt;nnoremap &lt;silent&gt; &lt;space&gt;p  :&lt;C-u&gt;CocListResume&lt;CR&gt;nnoremap &lt;silent&gt; K :call &lt;SID&gt;show_documentation()&lt;CR&gt;inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;      \ pumvisible() ? &quot;\&lt;C-n&gt;&quot; :      \ &lt;SID&gt;check_back_space() ? &quot;\&lt;TAB&gt;&quot; :      \ coc#refresh()inoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? &quot;\&lt;C-p&gt;&quot; : &quot;\&lt;C-h&gt;&quot;inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-space&gt; coc#refresh()xmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)nmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)nmap &lt;leader&gt;ac  &lt;Plug&gt;(coc-codeaction)nmap &lt;leader&gt;qf  &lt;Plug&gt;(coc-fix-current)xmap if &lt;Plug&gt;(coc-funcobj-i)xmap af &lt;Plug&gt;(coc-funcobj-a)omap if &lt;Plug&gt;(coc-funcobj-i)omap af &lt;Plug&gt;(coc-funcobj-a)nmap &lt;silent&gt; &lt;TAB&gt; &lt;Plug&gt;(coc-range-select)xmap &lt;silent&gt; &lt;TAB&gt; &lt;Plug&gt;(coc-range-select)xmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)nmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)command! -nargs=0 Format :call CocAction(&#39;format&#39;)command! -nargs=? Fold :call     CocAction(&#39;fold&#39;, &lt;f-args&gt;)command! -nargs=0 OR   :call     CocAction(&#39;runCommand&#39;, &#39;editor.action.organizeImport&#39;)autocmd CursorHold * silent call CocActionAsync(&#39;highlight&#39;)function! s:show_documentation()  if (index([&#39;vim&#39;,&#39;help&#39;], &amp;filetype) &gt;= 0)    execute &#39;h &#39;.expand(&#39;&lt;cword&gt;&#39;)  else    call CocAction(&#39;doHover&#39;)  endifendfunctionfunction! s:check_back_space() abort  let col = col(&#39;.&#39;) - 1  return !col || getline(&#39;.&#39;)[col - 1]  =~# &#39;\s&#39;endfunctionif has(&#39;patch8.1.1068&#39;)  inoremap &lt;expr&gt; &lt;cr&gt; complete_info()[&quot;selected&quot;] != &quot;-1&quot; ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;else  imap &lt;expr&gt; &lt;cr&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;endifaugroup mygroup  autocmd!  autocmd FileType typescript,json setl formatexpr=CocAction(&#39;formatSelected&#39;)  autocmd User CocJumpPlaceholder call CocActionAsync(&#39;showSignatureHelp&#39;)augroup end&quot;Goyolet g:goyo_width = 150nnoremap &lt;Leader&gt;gy :Goyo&lt;CR&gt;function! s:goyo_enter()  set number relativenumberendfunctionautocmd! User GoyoEnter nested call &lt;SID&gt;goyo_enter()&quot;NERDTreennoremap &lt;silent&gt; &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTree&quot;) &amp;&amp; b:NERDTree.isTabTree()) | q | endiflet g:NERDTreeDirArrowExpandable = &#39;&#39;let g:NERDTreeDirArrowCollapsible = &#39;&#39;&quot;Jedilet g:jedi#goto_definitions_command = &quot;gd&quot;let g:jedi#rename_command = &quot;&lt;leader&gt;rn&quot;</code></pre><h2 id="Plugins-Justification"><a href="#Plugins-Justification" class="headerlink" title="Plugins Justification"></a>Plugins Justification</h2><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><pre><code class="vim">Plug &#39;challenger-deep-theme/vim&#39;, { &#39;as&#39;: &#39;challenger-deep&#39; }&quot;Challenger Deeplet g:challenger_deep_termcolors = 16if has(&#39;nvim&#39;) || has(&#39;termguicolors&#39;)  set termguicolorsendifcolorscheme challenger_deep</code></pre><p>For theme I’m using <a href="https://github.com/challenger-deep-theme/vim" target="_blank" rel="noopener">Challenger Deep</a>. I can’t really say much other than I love the color scheme it provides. It is so me.</p><h3 id="Fuzzy-Search"><a href="#Fuzzy-Search" class="headerlink" title="Fuzzy Search"></a>Fuzzy Search</h3><p><img src="https://i.imgur.com/LCL7wl2.png" alt="Fuzzy Search using FZF + RipGrep"></p><p><strong>.vimrc</strong></p><pre><code class="vim">Plug &#39;junegunn/fzf&#39;, { &#39;dir&#39;: &#39;~/.fzf&#39;, &#39;do&#39;: &#39;./install --all&#39; }Plug &#39;junegunn/fzf.vim&#39;&quot;FZF RGnnoremap &lt;silent&gt; &lt;C-p&gt; :FZF&lt;CR&gt;function! RipgrepFzf(query, fullscreen)  let command_fmt = &#39;rg --column --line-number --no-heading --color=always --smart-case %s || true&#39;  let initial_command = printf(command_fmt, shellescape(a:query))  let reload_command = printf(command_fmt, &#39;{q}&#39;)  let spec = {&#39;options&#39;: [&#39;--phony&#39;, &#39;--query&#39;, a:query, &#39;--bind&#39;, &#39;change:reload:&#39;.reload_command]}  call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)endfunctioncommand! -nargs=* -bang Rg call RipgrepFzf(&lt;q-args&gt;, &lt;bang&gt;0)</code></pre><p><strong>.zshrc / .bshrc</strong></p><pre><code class="zsh">[ -f ~/.fzf.zsh ] &amp;&amp; source ~/.fzf.zshexport FZF_DEFAULT_COMMAND=&#39;rg --files --no-ignore --hidden --follow --glob &quot;!.git/*&quot;&#39;</code></pre><p>So for fuzzy search I’m using <a href="https://github.com/junegunn/fzf.vim" target="_blank" rel="noopener">FZF</a> combined with <a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">RipGrep</a>, main reason: <strong>Performance</strong>. RipGrep is another <em>grep</em> which claimed by many people as the fastest <em>grep</em> there is. It’s written in rust, which is another reason why I like it. This setup above let me use <code>:Rg text</code> to fuzzy find, and yes as it’s claimed, it’s blazingly fast even in extremly heavy code base. It also provides a peeking window.</p><h3 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h3><p><img src="https://i.imgur.com/C6WOQHW.png" alt="Opened FloaTerm"></p><pre><code class="vim">Plug &#39;voldikss/vim-floaterm&#39;&quot;FloaTermlet g:floaterm_keymap_toggle = &#39;&lt;Leader&gt;`&#39; </code></pre><p>For terminal I’m using <a href="https://github.com/voldikss/vim-floaterm" target="_blank" rel="noopener">FloaTerm</a>, I was initially planning on not using any terminal emulator in vim since it can be done easily by doing <code>!</code> command, but when I saw voldikss’ post about this on reddit it got me hooked. First of all its aesthethic and performace is top notch. Second it’s so easy to use, not much settings needed, the only custom thing I changed is the keymap.</p><h3 id="File-Explorer"><a href="#File-Explorer" class="headerlink" title="File Explorer"></a>File Explorer</h3><p><img src="https://i.imgur.com/Boxo0UA.png" alt="Opened NERDTree"></p><pre><code class="vim">Plug &#39;preservim/nerdtree&#39;Plug &#39;ryanoasis/vim-devicons&#39;&quot;NERDTreennoremap &lt;silent&gt; &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTree&quot;) &amp;&amp; b:NERDTree.isTabTree()) | q | endiflet g:NERDTreeDirArrowExpandable = &#39;&#39;let g:NERDTreeDirArrowCollapsible = &#39;&#39;</code></pre><p><a href="https://github.com/preservim/nerdtree" target="_blank" rel="noopener">NERDTree</a> is I think one of the everyone’s go-to vim plugin just cause how necessary it is. Above config lets NERDTree to close when all files are closed and also remove the default <em>expandable</em> and <em>collapsible</em> symbol. Combined with <a href="https://github.com/ryanoasis/vim-devicons" target="_blank" rel="noopener">devicons</a> it will give you nice file icons. <strong>Note</strong>: you have to use <a href="https://github.com/ryanoasis/nerd-fonts#patched-fonts" target="_blank" rel="noopener">Nerd font compatible</a> for the icons to show.</p><h2 id="TO-BE-CONTINUED-WHEN-I-HAVE-TIME-SORRY"><a href="#TO-BE-CONTINUED-WHEN-I-HAVE-TIME-SORRY" class="headerlink" title="TO BE CONTINUED WHEN I HAVE TIME, SORRY"></a>TO BE CONTINUED WHEN I HAVE TIME, SORRY</h2>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Terminal </tag>
            
            <tag> Vim </tag>
            
            <tag> Nvim </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
